# マシンの状態 - メモリ、レジスタなど

これまで、angrの動作に関する基本的な概念を示すために、angrがシミュレーションするプログラム状態（`SimState`オブジェクト）の必要最小限の使い方しかしてきませんでした。ここでは、状態オブジェクトの構造と、状態オブジェクトとのさまざまな便利な対話方法について学びます。

## おさらい: メモリとレジスタの読み書き

この本を順番に読んできた人なら（少なくともこの最初のセクションはそうすべきです）、メモリやレジスタにアクセスする方法の基本はすでに見たはずです。
`state.regs`は、各レジスタの名前を持つ属性を通してレジスタへの読み書きを提供します。`state.mem`は、アドレスを指定するインデックス表記のあとに、メモリの解釈に使う型の名前を持つ属性を通してメモリへの型付きの読み書きを提供します。

さらに、ASTの使い方を理解したことで、ビットベクトル型のASTであればレジスタやメモリに格納可能なことがが理解できるようになったはずです。

ここでは、状態からデータをコピーして操作を実行する簡単な例を紹介します:

```python
>>> import angr, claripy
>>> proj = angr.Project('/bin/true')
>>> state = proj.factory.entry_state()

# rbpをrspにコピーする
>>> state.regs.rbp = state.regs.rsp

# メモリのアドレス0x1000にrdxを格納する
>>> state.mem[0x1000].uint64_t = state.regs.rdx

# rbpの参照を外す
>>> state.regs.rbp = state.mem[state.regs.rbp].uint64_t.resolved

# add rax, qword ptr [rsp + 8]
>>> state.regs.rax += state.mem[state.regs.rsp + 8].uint64_t.resolved
```

## 基本的な実行方法

先に、Simulation Managerを使った基本的な実行方法を示しました。
次の章ではSimulation Managerの全機能を紹介しますが、ここではもっと簡単なインターフェイスである`state.step()`を使ってシンボリック実行がどのように機能するのかを示します。
このメソッドはシンボリック実行の1ステップを実行し、[`SimSuccessors`](http://angr.io/api-doc/angr.html#module-angr.engines.successors)と呼ばれるオブジェクトを返します。
通常のエミュレーションとは異なり、シンボリック実行ではさまざまな方法で分類される複数の後継状態を生成できます。
いまのところ、このオブジェクトの`.successors`プロパティに注目しています。これは、与えられたステップの「通常の」後継者をすべて含むリストです。

なぜ1つの後継状態ではなく、リストなのでしょうか？
angrのシンボリック実行の処理は、プログラムにコンパイルされた個々の命令の演算を取り出し、それを実行してSimStateを変化させるだけです。
`if (x > 4)`のようなコード行に到達したとき、xがシンボリックなビットベクトルだった場合どうなるのでしょうか？
angrの深部のどこかで`x > 4`の比較が実行され、その結果は`<Bool x_32_1 > 4>`となります。

それはよいとして、次の質問は、「真」の分岐を取るか「偽」の分岐を取るか、ということです。
答えは両方です！
条件が真であったときのシミュレーションと、偽であったときのシミュレーションの、2つのまったく別の後継状態を生成します。
前者の状態では制約として`x > 4`を追加し、後者の状態では制約として`!(x > 4)`を追加します。
このようにして、これらの後継状態のいずれかを使用して制約解消を実行するときはいつでも、*状態の条件によって得られるすべての解が、与えられた状態がたどったのと同じパスを実行することになる有効な入力であることが保証されます。*

これを示すために、[偽のファームウェアイメージ](../examples/fauxware/fauxware)を例として使ってみましょう。
このバイナリの[ソースコード](../examples/fauxware/fauxware.c)を読むと、ファームウェアの認証機構がバックドアになっていることがわかります。どんなユーザー名でもパスワード「SOSNEAKY」で管理者として認証することが可能なのです。
さらに、バックドアに対する比較がユーザー入力に対して最初に行われます。したがって、複数の後継状態が得られるまでステップすると、それらの状態の1つはユーザー入力がバックドアパスワードであることを制約として持つことになります。
次のスニペットはこれを実装したものです:

```python
>>> proj = angr.Project('examples/fauxware/fauxware')
>>> state = proj.factory.entry_state(stdin=angr.SimFile)  # ここでは教育のためにより複雑なデフォルト設定を無効にしています
>>> while True:
...     succ = state.step()
...     if len(succ.successors) == 2:
...         break
...     state = succ.successors[0]

>>> state1, state2 = succ.successors
>>> state1
<SimState @ 0x400629>
>>> state2
<SimState @ 0x400699
```

これらの状態の制約を直接見てはいけません。ここで通過した分岐は`strcmp`の結果を含んでおり、シンボリックにエミュレートするには厄介な関数であるため結果として制約も _非常に_ 複雑なものとなっています。

angrはデフォルトで標準入力をシンボリックデータの無限のストリームとして扱い、エミュレートしたプログラムはここからデータを取得します。
制約解消を行い、制約を満たすような入力値を得るには、stdinの実際の内容への参照を得る必要があります。
ファイルサブシステムと入力サブシステムがどのように動作するかについてはこのページの後半で説明しますが、ここではstdinからこれまでに読み込まれたすべての内容を表すビットベクトルを取得するために`state.posix.stdin.load(0, state.posix.stdin.size)`を使用するだけでよいでしょう。

```python
>>> input_data = state1.posix.stdin.load(0, state1.posix.stdin.size)

>>> state1.solver.eval(input_data, cast_to=bytes)
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00\x00\x00'

>>> state2.solver.eval(input_data, cast_to=bytes)
b'\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x00\x80N\x00\x00 \x00\x00\x00\x00'
```

ご覧の通り、`state1`へ進むにはパスワードとしてバックドアの文字列である「SOSNEAKY」を与える必要があります。
`state2`へ進むには「SOSNEAKY」 _以外の_ ものを渡さなければなりません。
z3はこの条件にあう数十億の文字列のうち1つを親切にも提供してくれています。

Fauxwareは2013年にangrのシンボリック実行が成功した最初のプログラムです。angrを使ってそのバックドアを見つけることで、あなたはバイナリから意味を抽出するための基本的なシンボリック実行の使い方を理解するという立派な伝統に参加することになるのです！

## プリセットの状態

これまで、状態を扱うときはいつでも`project.factory.entry_state()`を使って状態を作成してきました。
これは、プロジェクトのファクトリーで利用可能ないくつかの *状態のコンストラクター* の1つに過ぎません:

- `.blank_state()`は、ほとんどのデータが初期化されていない「白紙状態」のブランクな状態を構築します。
  初期化されていないデータにアクセスする場合、制約のないシンボル値が返されます。
- `.entry_state()`は、メインバイナリのエントリポイントで実行可能な状態を構築します。
- `.full_init_state()`は、メインバイナリのエントリポイントの前に実行する必要があるすべてのイニシャライザー（たとえば、共有ライブラリのコンストラクターやプリイニシャライザー）を介して実行する準備が整った状態を構築します。
  これらの実行が完了すると、エントリポイントにジャンプします。
- `.call_state()`は、与えられた関数を実行する準備ができている状態を構築します。

これらのコンストラクターのいくつかの引数を通じて、状態をカスタマイズできます:

- これらのコンストラクターはすべて`addr`引数を取り、開始アドレスを指定できます。

- コマンドライン引数が取得できる環境で実行する場合、`entry_state`と`full_init_state`には`args`を通して引数のリストを、`env`を通して環境変数の辞書を渡すことができます。
  これらの引数の値は文字列またはビットベクトルであり、実行のシミュレーションに与える引数と環境としての状態にシリアライズされます。
  デフォルトの`args`は空のリストなので、解析対象のプログラムが少なくとも`argv[0]`を参照できることを期待しているならば、常にそれを提供するべきです！

- `argc`をシンボリックにしたい場合は、`entry_state`と`full_init_state`コンストラクターには`argc`としてシンボリックなビットベクトルを渡すことができます。
  この場合、argcの値は`args`に渡した引数の数より大きいという制約を、構築した状態に追加する必要があることに注意してください。
  
- 呼び出し状態を利用するには、`.call_state(addr, arg1, arg2, ...)`のように呼び出す必要があります。ここで`addr`は呼び出したい関数のアドレスです。また、`argN`はその関数のN番目の引数で、Pythonの整数、文字列、配列、またはビットベクトルが使用できます。
  もし、オブジェクトのメモリを確保して、そのポインターを渡したい場合は、PointerWrapperでラップする必要があります。つまり、`angr.PointerWrapper("point to me!")`となります。
  このAPIの結果は少し予測できないことがありますが、私達はその修正に取り組んでいます。
  
- `call_state`で関数に使用される呼び出し規約を指定するには、`cc`引数として[`SimCC`インスタンス](http://angr.io/api-doc/angr.html#module-angr.calling_conventions)を渡します。
  適切なものをデフォルトで選択しますが、特殊な場合ではangrを助ける必要があります。

これらのコンストラクターで使用できるオプションは、他にもいくつかあります！詳しくは[`project.factory`オブジェクト（`AngrObjectFactory`）のドキュメント](http://angr.io/api-doc/angr.html#angr.factory.AngrObjectFactory)を参照してください。

## メモリに関する低レベルのインターフェイス

`state.mem`インターフェイスはメモリから型付けされたデータをロードするのには便利ですが、メモリの特定の範囲で直接データを読み書きしたいときには非常に面倒です。
`state.mem`は、実際にはビットベクトルのデータで満たされたフラットアドレス空間のメモリストレージである`state.memory`にアクセスするためのロジックの束に過ぎません。
`.load(addr, size)`と`.store(addr, val)`メソッドを使って`state.memory`を直接扱うことができます:

```python
>>> s = proj.factory.blank_state()
>>> s.memory.store(0x4000, s.solver.BVV(0x0123456789abcdef0123456789abcdef, 128))
>>> s.memory.load(0x4004, 6) # ロードサイズはバイト単位
<BV48 0x89abcdef0123>
```

ご覧の通り、`state.memory`の主な目的はセマンティクスを伴わないデータの読み書きであるため、データは「ビッグエンディアン」方式で読み書きされます。
しかし、読み書きしたデータに対してバイトスワップを行いたい場合はキーワード引数`endness`を渡すことができます。リトルエンディアンを指定するとバイトスワップが行われます。
endnessは、angrのCPUアーキテクチャに関する宣言型を提供する`archinfo`パッケージで定義されている、`Endness` enumのメンバーのいずれかである必要があります。
さらに、解析対象のプログラムのendnessは`state.arch.memory_endness`のように、`arch.memory_endness`として知ることができます。

```python
>>> import archinfo
>>> s.memory.load(0x4000, 4, endness=archinfo.Endness.LE)
<BV32 0x67452301>
```

また、`state.memory`とまったく同じAPIを使う`state.registers`というレジスタアクセスのための低レベルのインターフェイスがありますが、その動作を説明するには複数のアーキテクチャをシームレスに扱うためのangrの抽象化機能に[踏み込む](ir.md)必要があります。
簡単に説明すると、レジスタとオフセットのマッピングが[archinfo](https://github.com/angr/archinfo)で定義されている、単純なレジスタファイルということです。

## 状態のオプション

angrの内部には、ある場合には動作を最適化し、別の場合には不利になるような小さな微調整がたくさんあります。
これらの微調整は状態のオプションで制御します。

各SimStateオブジェクトには、有効なオプションのセット（`state.options`）が存在します。
各オプション（実際には単なる文字列）は、angrの実行エンジンの動作を細かく制御します。
すべてのオプションの一覧と、さまざまな状態型におけるデフォルト値は[付録](appendices/options.md)に記載されています。
状態のそれぞれのオプションには`angr.options`を通じてアクセスできます。
それぞれのオプションは大文字で命名されますが、まとめて使いたいような共通のグループ化されたオブジェクトが小文字で命名されることもあります。

SimStateをコンストラクターで作成する場合はキーワード引数の`add_options`と`remove_options`を渡すことができ、これらは最初のオプションセットをデフォルト値から変更するオプションセットである必要があります。

```python
# 例: 遅延解決を有効にします。これは状態の充足可能性をできるだけ頻繁にチェックしないようにするオプションです。
# この設定の変更は、この行以降にこの状態から作成されるすべての後継状態に伝搬されます。
>>> s.options.add(angr.options.LAZY_SOLVES)

# 遅延解決を有効にした新しい状態を作成します。
>>> s = proj.factory.entry_state(add_options={angr.options.LAZY_SOLVES})

# 単純化のオプションを無効にした新しい状態を作成します。
>>> s = proj.factory.entry_state(remove_options=angr.options.simplification)
```

## State Plugins

さきほど紹介したオプションを除いて、SimStateに保存されているものは、実際には状態に付属する _プラグイン_ にすべて保存されています。
`memory`、`registers`、`mem`、`regs`、`solver`などのこれまで説明してきた状態に関するほぼすべてのプロパティがプラグインです。
この設計によって、コードのモジュール化ができるだけでなく、エミュレートされた状態の他の側面に対する[新しい種類の状態のデータストレージを簡単に実装したり](state_plugins.md)、プラグインの代替実装を提供したりできます。

たとえば、通常の`memory`プラグインはフラットメモリ空間をシミュレートしますが、「abstract memory」プラグインを有効にすることでアドレスに依存しない自由なメモリマッピングをシミュレートでき、分析ではアドレスに別のデータ型を使用した`state.memory`を利用できます。
逆に、プラグインはコードの複雑さを軽減できます。`state.memory`と`state.registers`は実際には同じプラグインの異なるインスタンスで、レジスタはアドレス空間も含めてエミュレートされるからです。

### globalsプラグイン

`state.globals` は非常にシンプルなプラグインです。標準的なPythonのdictのインターフェイスを実装しており、任意のデータを状態に格納できます。

### historyプラグイン

`state.history`は、実行中に状態がたどった経路についての履歴データを保存する、非常に重要なプラグインです。
このリストは`state.history.parent.parent`などでたどっていくことができます。

この構造をより便利に扱うために、historyは特定の値の履歴に対するいくつかの効率的なイテレータも提供します。
一般的に、これらの値は `history.recent_NAME`として保存され、それらに対するイテレータは`history.NAME`となります。
たとえば、`for addr in state.history.bbl_addrs: print hex(addr)`はバイナリの基本ブロックアドレスのトレースを出力します。一方で`state.history.recent_bbl_addrs`は最後のステップで実行した基本ブロックのリスト、`state.history.parent.recent_bbl_addrs`は前のステップで実行した基本ブロックのリストといったように、それぞれのステップの基本ブロックが出力されます。
これらの値のフラットなリストを素早く取得したい場合は、`.hardcopy`にアクセスします（例: `state.history.bbl_addrs.hardcopy`）。
しかし、インデックスベースのアクセスはイテレータに実装されていることに注意してください。

以下は、履歴に保存されている値の簡単なリストです:

- `history.descriptions`は、状態に対して実行された各ラウンドの文字列の説明のリストです。
- `history.bbl_addrs`は、状態で実行された基本ブロックアドレスのリストです。
  実行ラウンドごとに1つ以上存在する可能性があります。ただし、すべてのアドレスがバイナリコードに対応するわけではありません。
- `history.jumpkinds`は、状態の履歴における各制御フロー遷移の処理を、VEX enum文字列としてリスト化したものです。
- `history.jump_guards`は、その状態が遭遇した各分岐をガードする条件のリストです。
- `history.events`は、シンボリックジャンプ条件の存在や、プログラムがメッセージボックスをポップアップしたり、ある終了コードで実行を終了したりといった、実行中に起こった「興味深いイベント」のセマンティックなリストです。
- `history.actions`は通常空ですが、`angr.options.refs`オプションを追加すると、プログラムが実行したすべてのメモリ、レジスタ、一時値のアクセスのログが入力されるようになります。

### callstackプラグイン

angrはエミュレートされたプログラムのコールスタックを追跡します。
call命令が実行されるたびに追跡コールスタックの先頭へフレームが追加され、一番上にあるフレームが呼び出された時点よりスタックポインターが小さくなると、フレームが取り出されます。
これにより、angrは現在エミュレートしている関数内のローカルなデータを堅牢に保存すできます。

historyと同様に、コールスタックもノードのリンクリストですが、ノードの内容に対するイテレータは提供されていません。代わりに、`state.callstack`を直接イテレートして、アクティブな各フレームのコールスタックフレームを、最新のものから古いものの順に取得することが可能です。
もし、一番上のフレームが欲しいだけなら、`state.callstack`を使用します。

- `callstack.func_addr`は、現在実行されている関数のアドレスです。
- `callstack.call_site_addr`は、現在の関数を呼び出した基本ブロックのアドレスです。
- `callstack.stack_ptr`は、現在の関数が呼び出された時点でのスタックポインターの値です。
- `callstack.ret_addr`は、現在の関数からリターンしたときに戻る場所です。

## I/Oについて詳しく: ファイル、ファイルシステム、ネットワークソケット

angrにおけるI/Oのモデル化についてのより完全かつ詳細なドキュメントは、[ファイルシステム、ソケット、パイプを扱う](file_system.md)を参照してください。

## コピーとマージ

状態は非常に高速なコピーをサポートしているため、さまざまな可能性を探索できます:

```python
>>> proj = angr.Project('/bin/true')
>>> s = proj.factory.blank_state()
>>> s1 = s.copy()
>>> s2 = s.copy()

>>> s1.mem[0x1000].uint32_t = 0x41414141
>>> s2.mem[0x1000].uint32_t = 0x42424242
```

状態をマージすることもできます。

```python
# mergeはタプルを返します。1つ目の要素はマージ後の状態です。
# 2つ目の要素は状態フラグを示すシンボリック変数です。
# 3つ目の要素はマージが行われたかを示すブーリアン値です。
>>> (s_merged, m, anything_merged) = s1.merge(s2)

# この式は今、"AAAA" *か* "BBBB"に解決できる式です。
>>> aaaa_or_bbbb = s_merged.mem[0x1000].[uint32_t]
```

TODO: マージの限界について説明する
