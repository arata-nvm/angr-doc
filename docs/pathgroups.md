# シミュレーションマネージャー

angrでもっとも重要な制御インターフェイスはSimulationManagerです。これは、プログラムの状態空間を探索するための探索戦略を適用し、同時に状態のグループに対するシンボリックな実行を制御できます。
ここでは、その使い方を学びます。

シミュレーションマネージャーは、複数の状態を巧みに操ることができます。
状態は「スタッシュ」に整理され、ステップフォワード、フィルタリング、マージ、移動が思いのままに行えます。
このため、たとえば、2つの異なる状態のスタッシュを異なる速度でステップさせ、それらをマージできます。
ほとんどの操作でデフォルトのスタッシュは`active`スタッシュで、これは新しいシミュレーションマネージャーを初期化するときに状態が置かれる場所です。

### ステップ

シミュレーションマネージャーのもっとも基本的な機能は、与えられたスタッシュにあるすべての状態を1つの基本ブロックごとにステップフォワードすることです。
これを行うには`.step()`を使います。

```python
>>> import angr
>>> proj = angr.Project('examples/fauxware/fauxware', auto_load_libs=False)
>>> state = proj.factory.entry_state()
>>> simgr = proj.factory.simgr(state)
>>> simgr.active
[<SimState @ 0x400580>]

>>> simgr.step()
>>> simgr.active
[<SimState @ 0x400540>]
```

もちろん、スタッシュモデルの本当の魅力は、ある状態がシンボリック分岐条件に遭遇したとき、後継の状態が両方ともスタッシュに現れ、その両方を同期してステップすることができることです。
解析の制御をあまり気にせず、ただ何もなくなるまでステップを踏みたいときには、`.run()` メソッドを使えばよいです。

```python
# 最初のシンボリック分岐までステップする
>>> while len(simgr.active) == 1:
...    simgr.step()

>>> simgr
<SimulationManager with 2 active>
>>> simgr.active
[<SimState @ 0x400692>, <SimState @ 0x400699>]

# すべてが終了するまでステップする
>>> simgr.run()
>>> simgr
<SimulationManager with 3 deadended>
```

3つの状態がdeadendedになりました！
たとえば、ある状態が`exit`システムコールに到達して実行中に後継者を生成できなかった場合、その状態はactiveスタッシュから削除され、`deadended`スタッシュに配置されます。

### スタッシュの管理

他のスタッシュと連携する方法を見てみましょう。

スタッシュ間で状態を移動するには`.move()`を使用します。この関数は`from_stash`、`to_stash`、そして`filter_func`（オプション引数で、デフォルトではすべてを移動させます）を受け取ります。
たとえば、出力に特定の文字列が含まれるものをすべて移動させてみましょう:

```python
>>> simgr.move(from_stash='deadended', to_stash='authenticated', filter_func=lambda s: b'Welcome' in s.posix.dumps(1))
>>> simgr
<SimulationManager with 2 authenticated, 1 deadended>
```

状態を移動させるだけで、「authenticated」という名前の新しいスタッシュを作成することができました。
このスタッシュにあるすべての状態は標準出力に「Welcome」と表示されます。これは今のところ良い指標になっています。

各スタッシュは単なるリストであり、インデックスで要素を指定したりイテレートしたりして個々の状態にアクセスできますが、状態にアクセスするための代替方法もいくつか用意されています。
スタッシュの名前の前に`one_`を付けると、そのスタッシュの最初の状態が表示されます。
スタッシュの名前の前に`mp_`を付けると、そのスタッシュの[mulpyplexed](https://github.com/zardus/mulpyplexer)バージョンが表示されます。

```python
>>> for s in simgr.deadended + simgr.authenticated:
...     print(hex(s.addr))
0x1000030
0x1000078
0x1000078

>>> simgr.one_deadended
<SimState @ 0x1000030>
>>> simgr.mp_authenticated
MP([<SimState @ 0x1000078>, <SimState @ 0x1000078>])
>>> simgr.mp_authenticated.posix.dumps(0)
MP(['\x00\x00\x00\x00\x00\x00\x00\x00\x00SOSNEAKY\x00',
    '\x00\x00\x00\x00\x00\x00\x00\x00\x00S\x80\x80\x80\x80@\x80@\x00'])
```

もちろん、`step`、`run`などのパスのスタッシュを操作するメソッドは`stash`引数を取ることができ、どのスタッシュで操作するかを指定できます。

シミュレーションマネージャーには、スタッシュを管理するための便利なツールがたくさんあります。
今のところ、それらの残りに触れることはしませんが、APIドキュメントを確認してみると良いでしょう。TODO: リンク

## スタッシュの種類

スタッシュは好きなように使えますが、いくつかの特別な種類の状態を分類するために使われるスタッシュがいくつかあります。
これらは
These are:

| スタッシュ | 説明 |
|-------|-------------|
| active     | このスタッシュには、代替のスタッシュが指定されていない限り、デフォルトでステップされる状態が含まれています。 |
| deadended     | 有効な命令がもうない、その後継のすべての状態が充足不能、命令ポインターが無効など、何らかの理由で実行を継続できないとき、状態はdeadendedスタッシュに移動します。 |
| pruned        | `LAZY_SOLVES`を使用する場合、絶対に必要でないかぎり、状態が充足可能かどうかチェックしません。`LAZY_SOLVES`を使用しているときに状態が充足不能であることが判明すると、状態階層を走査して、その履歴の中で最初に充足不能になったものを特定します。その時点でのすべての子孫の状態（状態が充足不能から充足可能になることはないため、これも充足不能になります）が取り除かれてこのスタッシュに移動します。 |
| unconstrained | SimulationManagerのコンストラクターで`save_unconstrained`オプションが与えられると、制約がないと判断された（すなわち、命令ポインターがユーザーデータ、または他のシンボリックデータソースによって制御されている）状態がここに移動します。 |
| unsat | SimulationManagerのコンストラクターで`save_unsat`オプションが指定された場合、充足不能（矛盾した制約、たとえば入力が「AAAA」と「BBBB」の両方でなければならない）と判断された状態はここに移動します。 |

隠し場所ではない、もうひとつの状態のリストがあります。`errored`です。
実行中にエラーが発生した場合、状態は`ErrorRecord`オブジェクトにラップされ、そのオブジェクトにはその状態と発生したエラーが記録され、そのレコードは`errored`に挿入されます。
エラーを発生させた命令アドレスにおける状態を`record.state`で取得し、発生したエラーを`record.error`で確認し、`record.debug()`でエラーが発生した場所でデバッグシェルを起動できます。
これは非常に貴重なデバッグツールです。

### 簡単な探索

シンボリック実行で非常に一般的な操作は、あるアドレスに到達する状態を見つけ、他のアドレスを通過する状態をすべて破棄することです。
シミュレーションマネージャーには、このパターンのショートカットである`.explore()`メソッドがあります。

`.explore()`に`find`引数を渡して呼び出すと、その条件にマッチする状態が見つかるまで実行されます。
この条件には、停止する命令のアドレス、停止するアドレスのリスト、あるいは、状態を受け取ってそれが特定の基準を満たすかどうかを返す関数が使えます。
activeスタッシュの状態のいずれかが`find`条件にマッチすると、それらは`found`スタッシュに置かれ、実行が終了します。
このとき、見つかった状態を探索することもできますし、それを破棄して他の状態を探索することもできます。
また、`find`と同じフォーマットで`avoid`条件を指定することもできます。
状態がavoid条件にマッチすると、その状態は`avoided`スタッシュに格納され、実行が継続されます。
最後に、`num_find`引数は、リターンする前に見つけるべき状態の数を制御します。デフォルトは1です。
もちろん、これだけの数の解を見つける前にactiveスタッシュの状態を使い果たした場合は、いずれにせよ実行は停止します。

簡単なcrackmeの[例](./examples.md#reverseme-modern-binary-exploitation---csci-4968)を見てみましょう:

まず、バイナリをロードします。
```python
>>> proj = angr.Project('examples/CSCI-4968-MBE/challenges/crackme0x00a/crackme0x00a')
```

次に、SimulationManagerを作成します。
```python
>>> simgr = proj.factory.simgr()
```

次に、条件に合う状態（つまり、「勝利」条件）が見つかるまで、シンボリックに実行します。
```python
>>> simgr.explore(find=lambda s: b"Congrats" in s.posix.dumps(1))
<SimulationManager with 1 active, 1 found>
```

さて、その状態からフラグを出すことができます！
```python
>>> s = simgr.found[0]
>>> print(s.posix.dumps(1))
Enter password: Congrats!

>>> flag = s.posix.dumps(0)
>>> print(flag)
g00dJ0B!
```

かなりシンプルでしょう？

他の例は[例](./examples.md)を参照するとわかります。

## 探索手法

angrには、シミュレーションマネージャーの動作をカスタマイズするために準備された機能がいくつかあり、 _探索手法 と呼ばれています。
探索手法の典型的な例は、プログラムの状態空間を探索するパターンを変更することです。デフォルトの「すべてを一度にステップする」戦略は、実質的に幅優先探索ですが、探索手法を使えば、たとえば、深さ優先探索を実装できます。
しかし、これらの手法はそれよりもはるかに柔軟で、angrのステップ処理の動作を完全に変更できます。
独自の探索手法を書くことについては、後の章で説明します。

探索テクニックを使うには、`simgr.use_technique(tech)`を呼びます。techはExplorationTechniqueのサブクラスのインスタンスです。
angrのビルトインの探査手法は`angr.exploration_techniques`で確認できます。

ここでは、いくつかのビルトインの探索手法を簡単に紹介します:

- *DFS*: 先ほど説明した深さ優先探索です。1度に1つの状態だけをアクティブにして、残りは行き詰まるかエラーが起きるまで`deferred`スタッシュに置いておきます。
- *Explorer*: このテクニックは`.explore()`機能を実装しており、特定アドレスの探索と回避を可能にします。
- *LengthLimiter*: 状態が通過するパス数に上限を設定します。
- *LoopSeer*: ループカウントの合理的な近似を使用して、ループを何度も通過しているように見える状態を破棄します。破棄した状態は`spinning`スタッシュに移動し、他に実行可能な状態がなくなったときに再び取り出されます。
- *ManualMergepoint*: プログラム内のアドレスをマージポイントとしてマークし、そのアドレスに到達した状態を一時的に保持します。一定時間内に同じポイントに到達した他の状態は1つにマージされます。
- *MemoryWatcher*: simgrの1ステップの間に、システム上でどれくらいのメモリが空いているか/利用可能かを監視し、少なくなりすぎた場合は探索を停止します。
- *Oppologist*: とくに便利なのが「operation apologist」と呼ばれる仕組みです。この手法が有効な場合、angrがサポートされていない命令、たとえば奇妙な浮動小数点SIMD演算に遭遇すると、その命令へのすべての入力を具体化し、Unicorn Engineを使って単一の命令をエミュレートし、実行を継続できるようになります。
- *Spiller*: アクティブな状態が多すぎる場合、この手法は、メモリ消費を低く抑えるために、それらの一部をディスクにダンプできます。
- *Threading*: ステップ処理にスレッドレベルの並列性を追加します。Pythonのグローバルインタープリタロックのため、これはあまり役に立ちませんが、もし解析がangrのネイティブコード依存（unicorn, z3, libvex）で多くの時間を費やすプログラムを持っているなら、多少の効果を得ることができるようです。
- *Tracer*: 他のソースから取得した動的トレースにしたがって実行させる探索手法です。[動的トレーサーのリポジトリ](https://github.com/angr/tracer)には、これらのトレースを生成するためのツールがいくつかあります。
- *Veritesting*: [CMUの論文](https://users.ece.cmu.edu/~dbrumley/pdf/Avgerinos%20et%20al._2014_Enhancing%20Symbolic%20Execution%20with%20Veritesting.pdf)の実装で、有用なマージポイントを自動的に識別するものです。これはとても便利なため、SimulationManagerのコンストラクターで`veritesting=True`とすることで自動的に有効化できます！静的シンボリック実行を実装しているため、他の手法との相性が悪いことに注意してください。

詳しくは[シミュレーションマネージャー](http://angr.io/api-doc/angr.html#module-angr.manager)と[探索手法](http://angr.io/api-doc/angr.html#angr.exploration_techniques.ExplorationTechnique)のAPIドキュメントを見てください。
