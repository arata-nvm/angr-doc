# angrを使うときの落とし穴

このセクションでは、angrのユーザ/犠牲者が頻繁に遭遇する落とし穴をリストアップします。

## SimProcedureの不正確さ

シンボリック実行をより扱いやすくするために，angrは一般的なライブラリ関数をPythonで書かれたサマリーに置き換えます。
このサマリーをSimProcedureと呼びます。
SimProcedureは、例えば、`strlen`がシンボリック文字列で実行された場合に生じるパスの爆発を軽減することができます。

残念ながら、我々のSimProceduresは完璧とは言えません。
angrが予期しない挙動を示した場合、それはバグや不完全なSimProcedureが原因である可能性があります。
できることはいくつかあります。

1. SimProcedureを無効にする（[angr.Projectクラス](http://angr.io/api-doc/angr.html#module-angr.project)にオプションを渡すことにより、特定のSimProcedureを除外できます）。これは、問題となっている関数への入力を非常に注意深く制限しなければ、パス爆発につながる可能性が高いという欠点があります。パス爆発は、他のangrの機能（Veritestingなど）で部分的に緩和できます。
2. SimProcedureを、問題の状況に合わせて直接書かれたものに置き換える。例えば、私たちの`scanf`の実装は完全ではありませんが、単一の既知のフォーマット文字列をサポートする必要があるだけなら、まさにそれを行うためのフックを書くことができます。
3. SimProcedureを修正する。

## サポートされていないシステムコール

システムコールもSimProcedureとして実装されています。
残念ながら、angrではまだ実装していないシステムコールがあります。
サポートされていないシステムコールについて、いくつかの回避策があります。

1. システムコールを実装する。 *TODO: この作業を文書化する*
2. （`project.hook`を使って）システムコールの呼び出し元をフックして、アドホックに状態に必要な修正を加える。
3. `state.posix.queued_syscall_returns`リストを使って、システムコールの返り値をキューに入れま す。戻り値がキューに入れられると、システムコールは実行されず、代わりにその値が使用されます。さらに、関数を「戻り値」として代わりにキューに入れることもでき、その場合、システムコールが実行されたときに、その関数が状態に適用されます。

## シンボリックメモリーモデル

angrが使用するデフォルトのメモリモデルは[Mayhem](https://users.ece.cmu.edu/~dbrumley/pdf/Cha%20et%20al._2012_Unleashing%20Mayhem%20on%20Binary%20Code.pdf)に触発されたものです。
このメモリモデルは、シンボリックな読み書きに一部対応しています。
読み込みのメモリインデックスがシンボリックで、このインデックスの取り得る値の範囲が広すぎる場合、インデックスは1つの値に具体化されます。
書き込みのメモリインデックスが完全にシンボリックである場合、そのインデックスは単一の値に具体化されます。
これは、`state.memory`のメモリ具体化戦略を変更することで設定可能です。

## シンボリックな長さ

SimProcedure、特に`read()`や`write()`などのシステムコールは、バッファの *length* がシンボリックである場合があります。
多くの場合、この長さはそのまま具体化されるか、あるいは後の実行段階で遡及的に具体化されることになります。
そうでない場合でも、ソースファイルやデスティネーションファイルの見た目が少し「変」になってしまうかもしれません。

## ゼロ除算

Z3はゼロ除算についていくつかの問題を抱えています。
たとえば:

```
>>> z = z3.Solver()
>>> a = z3.BitVec('a', 32)
>>> b = z3.BitVec('b', 32)
>>> c = z3.BitVec('c', 32)
>>> z.add(a/b == c)
>>> z.add(b == 0)
>>> z.check()
>>> print(z.model().eval(b), z.model().eval(a/b))
0 4294967295
```

このため、Claripyで特定の状況を処理することは非常に困難です。
VEX IR自体を後処理してゼロ除算を明示的にチェックし、例外的なケースに対応するIRSBの出口を作成しますが、SimProcedureや独自の解析コードではゼロ除算が発生すると分岐してしまい、解析で奇妙な問題が発生する可能性があります。
安全のため、割り算をする場合は、分母がゼロであることに対する制約を追加してください。
